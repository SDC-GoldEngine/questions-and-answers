const { Pool, Client } = require('pg');

module.exports = async () => {
  return;
  const client = new Client({
    database: 'template1',
  });

  try {
    await client.connect();
    await client.query(`DROP DATABASE IF EXISTS ${process.env.PGDATABASE};`);
    await client.query(`CREATE DATABASE ${process.env.PGDATABASE};`);
    await client.end();
    console.log(`Database ${process.env.PGDATABASE} created.`);

    const pool = new Pool();

    await pool.query(`
      CREATE TABLE IF NOT EXISTS questions(
        id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        product_id integer NOT NULL,
        body text NOT NULL,
        date bigint,
        name text NOT NULL,
        email text NOT NULL,
        reported boolean DEFAULT FALSE,
        helpfulness integer DEFAULT 0
      );

      CREATE TABLE IF NOT EXISTS answers(
        id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        question_id integer NOT NULL REFERENCES questions ON DELETE CASCADE,
        body text NOT NULL,
        date bigint,
        name text NOT NULL,
        email text NOT NULL,
        reported boolean DEFAULT FALSE,
        helpfulness integer DEFAULT 0
      );

      CREATE TABLE IF NOT EXISTS answers_photos(
        id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        answer_id integer NOT NULL REFERENCES answers ON DELETE CASCADE,
        url text NOT NULL
      );
    `);
    console.log('Tables questions, answers, and answers_photos created.');

    await Promise.all([
      await pool.query(`
        COPY questions (id, product_id, body, date, name, email, reported, helpfulness)
          FROM '${process.env.DBPATH}/questions.csv'
          WITH CSV HEADER;
      `),
      await pool.query(`
        COPY answers (id, question_id, body, date, name, email, reported, helpfulness)
          FROM '${process.env.DBPATH}/answers.csv'
          WITH CSV HEADER;
      `),
      await pool.query(`
        COPY answers_photos (id, answer_id, url)
          FROM '${process.env.DBPATH}/answers_photos.csv'
          WITH CSV HEADER;
      `),
    ]);
    console.log('Tables questions, answers, and answers_photos populated.');

    await pool.query(`
      ALTER TABLE questions
        ADD CONSTRAINT question_body_length CHECK (length(body) <= 1e4),
        ADD CONSTRAINT question_name_length CHECK (length(name) <= 1e2),
        ADD CONSTRAINT question_email_length CHECK (length(email) <= 1e2),
        ALTER COLUMN date TYPE timestamp(3) with time zone
          USING to_timestamp(date / 1000.0),
        ALTER COLUMN date SET DEFAULT CURRENT_TIMESTAMP(3);

      SELECT setval('questions_id_seq', (SELECT max(id) FROM questions));

      ALTER TABLE answers
        ADD CONSTRAINT answer_body_length CHECK (length(body) <= 1e4),
        ADD CONSTRAINT answer_name_length CHECK (length(name) <= 1e2),
        ADD CONSTRAINT answer_email_length CHECK (length(email) <= 1e2),
        ALTER COLUMN date TYPE timestamp(3) with time zone
          USING to_timestamp(date / 1000.0),
        ALTER COLUMN date SET DEFAULT CURRENT_TIMESTAMP(3);

      SELECT setval('answers_id_seq', (SELECT max(id) FROM answers));

      SELECT setval('answers_photos_id_seq', (SELECT max(id) FROM answers_photos));

      CREATE INDEX questions_product_id_index ON questions (product_id);
      CREATE INDEX questions_date_index ON questions (date DESC);
      CREATE INDEX answers_question_id_index ON answers (question_id);
      CREATE INDEX answers_date_index ON answers (date DESC);
      CREATE INDEX answers_photos_answer_id_index ON answers_photos (answer_id);
      `);
    console.log(
      'Constraints placed on tables questions and answers.\nColumns questions.question_date and answers.date converted to type timestamp.\nPrimary keys advanced.\nIndexes created on ids and dates.'
    );
  } catch (error) {
    console.log(`Failed to create database ${process.env.PGDATABASE}:`, error);
  }
};
